### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type Action {
  id: ID!
  remarks: String!
}

input ActionCreateManyWithoutActionsInput {
  connect: [ActionWhereUniqueInput!]
  create: [ActionCreateWithoutAssignmentInput!]
}

input ActionCreateWithoutAssignmentInput {
  id: ID
  remarks: String!
}

input ActionFilter {
  every: ActionWhereInput
  none: ActionWhereInput
  some: ActionWhereInput
}

input ActionScalarWhereInput {
  AND: [ActionScalarWhereInput!]
  id: StringFilter
  NOT: [ActionScalarWhereInput!]
  OR: [ActionScalarWhereInput!]
  remarks: StringFilter
}

input ActionUpdateManyDataInput {
  id: ID
  remarks: String
}

input ActionUpdateManyWithoutAssignmentInput {
  connect: [ActionWhereUniqueInput!]
  create: [ActionCreateWithoutAssignmentInput!]
  delete: [ActionWhereUniqueInput!]
  deleteMany: [ActionScalarWhereInput!]
  disconnect: [ActionWhereUniqueInput!]
  set: [ActionWhereUniqueInput!]
  update: [ActionUpdateWithWhereUniqueWithoutAssignmentInput!]
  updateMany: [ActionUpdateManyWithWhereNestedInput!]
  upsert: [ActionUpsertWithWhereUniqueWithoutAssignmentInput!]
}

input ActionUpdateManyWithWhereNestedInput {
  data: ActionUpdateManyDataInput!
  where: ActionScalarWhereInput!
}

input ActionUpdateWithoutAssignmentDataInput {
  id: ID
  remarks: String
}

input ActionUpdateWithWhereUniqueWithoutAssignmentInput {
  data: ActionUpdateWithoutAssignmentDataInput!
  where: ActionWhereUniqueInput!
}

input ActionUpsertWithWhereUniqueWithoutAssignmentInput {
  create: ActionCreateWithoutAssignmentInput!
  update: ActionUpdateWithoutAssignmentDataInput!
  where: ActionWhereUniqueInput!
}

input ActionWhereInput {
  AND: [ActionWhereInput!]
  assignment: AssignmentWhereInput
  id: StringFilter
  NOT: [ActionWhereInput!]
  OR: [ActionWhereInput!]
  remarks: StringFilter
}

input ActionWhereUniqueInput {
  id: ID
}

type Address {
  id: ID!
  text: String!
}

input AddressCreateManyWithoutAddressesInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutCustomerInput!]
}

input AddressCreateOneWithoutAddressInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutAssignmentsInput
}

input AddressCreateWithoutAssignmentsInput {
  customer: CustomerCreateOneWithoutCustomerInput
  id: ID
  text: String!
}

input AddressCreateWithoutCustomerInput {
  assignments: AssignmentCreateManyWithoutAssignmentsInput
  id: ID
  text: String!
}

input AddressFilter {
  every: AddressWhereInput
  none: AddressWhereInput
  some: AddressWhereInput
}

input AddressScalarWhereInput {
  AND: [AddressScalarWhereInput!]
  assignments: AssignmentFilter
  id: StringFilter
  NOT: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  text: StringFilter
}

input AddressUpdateManyDataInput {
  id: ID
  text: String
}

input AddressUpdateManyWithoutCustomerInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutCustomerInput!]
  delete: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  disconnect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
  upsert: [AddressUpsertWithWhereUniqueWithoutCustomerInput!]
}

input AddressUpdateManyWithWhereNestedInput {
  data: AddressUpdateManyDataInput!
  where: AddressScalarWhereInput!
}

input AddressUpdateOneRequiredWithoutAssignmentsInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutAssignmentsInput
  update: AddressUpdateWithoutAssignmentsDataInput
  upsert: AddressUpsertWithoutAssignmentsInput
}

input AddressUpdateWithoutAssignmentsDataInput {
  customer: CustomerUpdateOneWithoutAddressesInput
  id: ID
  text: String
}

input AddressUpdateWithoutCustomerDataInput {
  assignments: AssignmentUpdateManyWithoutAddressInput
  id: ID
  text: String
}

input AddressUpdateWithWhereUniqueWithoutCustomerInput {
  data: AddressUpdateWithoutCustomerDataInput!
  where: AddressWhereUniqueInput!
}

input AddressUpsertWithoutAssignmentsInput {
  create: AddressCreateWithoutAssignmentsInput!
  update: AddressUpdateWithoutAssignmentsDataInput!
}

input AddressUpsertWithWhereUniqueWithoutCustomerInput {
  create: AddressCreateWithoutCustomerInput!
  update: AddressUpdateWithoutCustomerDataInput!
  where: AddressWhereUniqueInput!
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  assignments: AssignmentFilter
  customer: CustomerWhereInput
  id: StringFilter
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  text: StringFilter
}

input AddressWhereUniqueInput {
  id: ID
}

type Admin {
  id: ID!
  privilege: AdminPrivilege!
  username: String!
}

input AdminCreateInput {
  password: String!
  privilege: AdminPrivilege!
  username: String!
}

type AdminLoginResponse {
  adminId: String!
  adminPrivilege: AdminPrivilege!
  token: String!
}

input AdminOrderByInput {
  hash: OrderByArg
  id: OrderByArg
  privilege: OrderByArg
  username: OrderByArg
}

enum AdminPrivilege {
  BASIC
  FULL
}

input AdminUpdateInput {
  username: String
}

input AdminWhereInput {
  AND: [AdminWhereInput!]
  hash: StringFilter
  id: StringFilter
  NOT: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  privilege: AdminPrivilege
  username: StringFilter
}

input AdminWhereUniqueInput {
  id: ID
  username: String
}

type Assignment {
  actions(after: ID, before: ID, first: Int, last: Int, skip: Int): [Action!]!
  address: Address!
  checkIn: DateTime
  checkOut: DateTime
  id: ID!
  preferTime: DateTime
  staffPrimary: Staff!
  staffSecondary: Staff
  tasks(after: ID, before: ID, first: Int, last: Int, skip: Int): [Task!]!
}

input AssignmentCreateManyWithoutAssignmentPrimariesInput {
  connect: [AssignmentWhereUniqueInput!]
  create: [AssignmentCreateWithoutStaffPrimaryInput!]
}

input AssignmentCreateManyWithoutAssignmentSecondariesInput {
  connect: [AssignmentWhereUniqueInput!]
  create: [AssignmentCreateWithoutStaffSecondaryInput!]
}

input AssignmentCreateManyWithoutAssignmentsInput {
  connect: [AssignmentWhereUniqueInput!]
  create: [AssignmentCreateWithoutAddressInput!]
}

input AssignmentCreateWithoutAddressInput {
  actions: ActionCreateManyWithoutActionsInput
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  job: JobCreateOneWithoutJobInput
  preferTime: DateTime
  staffPrimary: StaffCreateOneWithoutStaffPrimaryInput!
  staffSecondary: StaffCreateOneWithoutStaffSecondaryInput
  tasks: TaskCreateManyWithoutTasksInput
}

input AssignmentCreateWithoutJobInput {
  actions: ActionCreateManyWithoutActionsInput
  address: AddressCreateOneWithoutAddressInput!
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  preferTime: DateTime
  staffPrimary: StaffCreateOneWithoutStaffPrimaryInput!
  staffSecondary: StaffCreateOneWithoutStaffSecondaryInput
  tasks: TaskCreateManyWithoutTasksInput
}

input AssignmentCreateWithoutStaffPrimaryInput {
  actions: ActionCreateManyWithoutActionsInput
  address: AddressCreateOneWithoutAddressInput!
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  job: JobCreateOneWithoutJobInput
  preferTime: DateTime
  staffSecondary: StaffCreateOneWithoutStaffSecondaryInput
  tasks: TaskCreateManyWithoutTasksInput
}

input AssignmentCreateWithoutStaffSecondaryInput {
  actions: ActionCreateManyWithoutActionsInput
  address: AddressCreateOneWithoutAddressInput!
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  job: JobCreateOneWithoutJobInput
  preferTime: DateTime
  staffPrimary: StaffCreateOneWithoutStaffPrimaryInput!
  tasks: TaskCreateManyWithoutTasksInput
}

input AssignmentFilter {
  every: AssignmentWhereInput
  none: AssignmentWhereInput
  some: AssignmentWhereInput
}

input AssignmentScalarWhereInput {
  actions: ActionFilter
  AND: [AssignmentScalarWhereInput!]
  checkIn: NullableDateTimeFilter
  checkOut: NullableDateTimeFilter
  id: StringFilter
  NOT: [AssignmentScalarWhereInput!]
  OR: [AssignmentScalarWhereInput!]
  preferTime: NullableDateTimeFilter
  tasks: TaskFilter
}

input AssignmentUpdateManyDataInput {
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  preferTime: DateTime
}

input AssignmentUpdateManyWithoutAddressInput {
  connect: [AssignmentWhereUniqueInput!]
  create: [AssignmentCreateWithoutAddressInput!]
  delete: [AssignmentWhereUniqueInput!]
  deleteMany: [AssignmentScalarWhereInput!]
  disconnect: [AssignmentWhereUniqueInput!]
  set: [AssignmentWhereUniqueInput!]
  update: [AssignmentUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [AssignmentUpdateManyWithWhereNestedInput!]
  upsert: [AssignmentUpsertWithWhereUniqueWithoutAddressInput!]
}

input AssignmentUpdateManyWithoutJobInput {
  connect: [AssignmentWhereUniqueInput!]
  create: [AssignmentCreateWithoutJobInput!]
  delete: [AssignmentWhereUniqueInput!]
  deleteMany: [AssignmentScalarWhereInput!]
  disconnect: [AssignmentWhereUniqueInput!]
  set: [AssignmentWhereUniqueInput!]
  update: [AssignmentUpdateWithWhereUniqueWithoutJobInput!]
  updateMany: [AssignmentUpdateManyWithWhereNestedInput!]
  upsert: [AssignmentUpsertWithWhereUniqueWithoutJobInput!]
}

input AssignmentUpdateManyWithoutStaffPrimaryInput {
  connect: [AssignmentWhereUniqueInput!]
  create: [AssignmentCreateWithoutStaffPrimaryInput!]
  delete: [AssignmentWhereUniqueInput!]
  deleteMany: [AssignmentScalarWhereInput!]
  disconnect: [AssignmentWhereUniqueInput!]
  set: [AssignmentWhereUniqueInput!]
  update: [AssignmentUpdateWithWhereUniqueWithoutStaffPrimaryInput!]
  updateMany: [AssignmentUpdateManyWithWhereNestedInput!]
  upsert: [AssignmentUpsertWithWhereUniqueWithoutStaffPrimaryInput!]
}

input AssignmentUpdateManyWithoutStaffSecondaryInput {
  connect: [AssignmentWhereUniqueInput!]
  create: [AssignmentCreateWithoutStaffSecondaryInput!]
  delete: [AssignmentWhereUniqueInput!]
  deleteMany: [AssignmentScalarWhereInput!]
  disconnect: [AssignmentWhereUniqueInput!]
  set: [AssignmentWhereUniqueInput!]
  update: [AssignmentUpdateWithWhereUniqueWithoutStaffSecondaryInput!]
  updateMany: [AssignmentUpdateManyWithWhereNestedInput!]
  upsert: [AssignmentUpsertWithWhereUniqueWithoutStaffSecondaryInput!]
}

input AssignmentUpdateManyWithWhereNestedInput {
  data: AssignmentUpdateManyDataInput!
  where: AssignmentScalarWhereInput!
}

input AssignmentUpdateWithoutAddressDataInput {
  actions: ActionUpdateManyWithoutAssignmentInput
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  job: JobUpdateOneWithoutAssignmentsInput
  preferTime: DateTime
  staffPrimary: StaffUpdateOneRequiredWithoutAssignmentPrimariesInput
  staffSecondary: StaffUpdateOneWithoutAssignmentSecondariesInput
  tasks: TaskUpdateManyWithoutAssignmentInput
}

input AssignmentUpdateWithoutJobDataInput {
  actions: ActionUpdateManyWithoutAssignmentInput
  address: AddressUpdateOneRequiredWithoutAssignmentsInput
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  preferTime: DateTime
  staffPrimary: StaffUpdateOneRequiredWithoutAssignmentPrimariesInput
  staffSecondary: StaffUpdateOneWithoutAssignmentSecondariesInput
  tasks: TaskUpdateManyWithoutAssignmentInput
}

input AssignmentUpdateWithoutStaffPrimaryDataInput {
  actions: ActionUpdateManyWithoutAssignmentInput
  address: AddressUpdateOneRequiredWithoutAssignmentsInput
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  job: JobUpdateOneWithoutAssignmentsInput
  preferTime: DateTime
  staffSecondary: StaffUpdateOneWithoutAssignmentSecondariesInput
  tasks: TaskUpdateManyWithoutAssignmentInput
}

input AssignmentUpdateWithoutStaffSecondaryDataInput {
  actions: ActionUpdateManyWithoutAssignmentInput
  address: AddressUpdateOneRequiredWithoutAssignmentsInput
  checkIn: DateTime
  checkOut: DateTime
  id: ID
  job: JobUpdateOneWithoutAssignmentsInput
  preferTime: DateTime
  staffPrimary: StaffUpdateOneRequiredWithoutAssignmentPrimariesInput
  tasks: TaskUpdateManyWithoutAssignmentInput
}

input AssignmentUpdateWithWhereUniqueWithoutAddressInput {
  data: AssignmentUpdateWithoutAddressDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpdateWithWhereUniqueWithoutJobInput {
  data: AssignmentUpdateWithoutJobDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpdateWithWhereUniqueWithoutStaffPrimaryInput {
  data: AssignmentUpdateWithoutStaffPrimaryDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpdateWithWhereUniqueWithoutStaffSecondaryInput {
  data: AssignmentUpdateWithoutStaffSecondaryDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpsertWithWhereUniqueWithoutAddressInput {
  create: AssignmentCreateWithoutAddressInput!
  update: AssignmentUpdateWithoutAddressDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpsertWithWhereUniqueWithoutJobInput {
  create: AssignmentCreateWithoutJobInput!
  update: AssignmentUpdateWithoutJobDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpsertWithWhereUniqueWithoutStaffPrimaryInput {
  create: AssignmentCreateWithoutStaffPrimaryInput!
  update: AssignmentUpdateWithoutStaffPrimaryDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpsertWithWhereUniqueWithoutStaffSecondaryInput {
  create: AssignmentCreateWithoutStaffSecondaryInput!
  update: AssignmentUpdateWithoutStaffSecondaryDataInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentWhereInput {
  actions: ActionFilter
  address: AddressWhereInput
  AND: [AssignmentWhereInput!]
  checkIn: NullableDateTimeFilter
  checkOut: NullableDateTimeFilter
  id: StringFilter
  job: JobWhereInput
  NOT: [AssignmentWhereInput!]
  OR: [AssignmentWhereInput!]
  preferTime: NullableDateTimeFilter
  staffPrimary: StaffWhereInput
  staffSecondary: StaffWhereInput
  tasks: TaskFilter
}

input AssignmentWhereUniqueInput {
  id: ID
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Company {
  alias: String!
  id: ID!
  name: String!
}

input CompanyCreateInput {
  alias: String!
  name: String!
}

input CompanyCreateOneWithoutCompanyBelongInput {
  connect: CompanyWhereUniqueInput
  create: CompanyCreateWithoutCustomersInput
}

input CompanyCreateWithoutCustomersInput {
  alias: String!
  id: ID
  name: String!
}

input CompanyUpdateInput {
  alias: String
  name: String
}

input CompanyUpdateOneWithoutCustomersInput {
  connect: CompanyWhereUniqueInput
  create: CompanyCreateWithoutCustomersInput
  delete: Boolean
  disconnect: Boolean
  update: CompanyUpdateWithoutCustomersDataInput
  upsert: CompanyUpsertWithoutCustomersInput
}

input CompanyUpdateWithoutCustomersDataInput {
  alias: String
  id: ID
  name: String
}

input CompanyUpsertWithoutCustomersInput {
  create: CompanyCreateWithoutCustomersInput!
  update: CompanyUpdateWithoutCustomersDataInput!
}

input CompanyWhereInput {
  alias: StringFilter
  AND: [CompanyWhereInput!]
  customers: CustomerFilter
  id: StringFilter
  name: StringFilter
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  alias: String
  id: ID
  name: String
}

type Customer {
  active: Boolean!
  addresses(after: ID, before: ID, first: Int, last: Int, skip: Int): [Address!]!
  code: String!
  companyBelong: Company
  email: String
  id: ID!
  name: String!
  phoneNumber: String
  staffPrimary: Staff!
  staffSecondary: Staff
  temporary: Boolean!
}

input CustomerCreateInput {
  active: Boolean
  addresses: AddressCreateManyWithoutAddressesInput
  code: String!
  companyBelong: CompanyCreateOneWithoutCompanyBelongInput
  email: String
  id: ID
  jobs: JobCreateManyWithoutJobsInput
  name: String!
  phoneNumber: String
  staffPrimary: StaffCreateOneWithoutStaffPrimaryInput!
  staffSecondary: StaffCreateOneWithoutStaffSecondaryInput
  temporary: Boolean
}

input CustomerCreateManyWithoutCustomerPrimariesInput {
  connect: [CustomerWhereUniqueInput!]
  create: [CustomerCreateWithoutStaffPrimaryInput!]
}

input CustomerCreateManyWithoutCustomerSecondariesInput {
  connect: [CustomerWhereUniqueInput!]
  create: [CustomerCreateWithoutStaffSecondaryInput!]
}

input CustomerCreateOneWithoutCustomerInput {
  connect: CustomerWhereUniqueInput
  create: CustomerCreateWithoutAddressesInput
}

input CustomerCreateWithoutAddressesInput {
  active: Boolean
  code: String!
  companyBelong: CompanyCreateOneWithoutCompanyBelongInput
  email: String
  id: ID
  jobs: JobCreateManyWithoutJobsInput
  name: String!
  phoneNumber: String
  staffPrimary: StaffCreateOneWithoutStaffPrimaryInput!
  staffSecondary: StaffCreateOneWithoutStaffSecondaryInput
  temporary: Boolean
}

input CustomerCreateWithoutJobsInput {
  active: Boolean
  addresses: AddressCreateManyWithoutAddressesInput
  code: String!
  companyBelong: CompanyCreateOneWithoutCompanyBelongInput
  email: String
  id: ID
  name: String!
  phoneNumber: String
  staffPrimary: StaffCreateOneWithoutStaffPrimaryInput!
  staffSecondary: StaffCreateOneWithoutStaffSecondaryInput
  temporary: Boolean
}

input CustomerCreateWithoutStaffPrimaryInput {
  active: Boolean
  addresses: AddressCreateManyWithoutAddressesInput
  code: String!
  companyBelong: CompanyCreateOneWithoutCompanyBelongInput
  email: String
  id: ID
  jobs: JobCreateManyWithoutJobsInput
  name: String!
  phoneNumber: String
  staffSecondary: StaffCreateOneWithoutStaffSecondaryInput
  temporary: Boolean
}

input CustomerCreateWithoutStaffSecondaryInput {
  active: Boolean
  addresses: AddressCreateManyWithoutAddressesInput
  code: String!
  companyBelong: CompanyCreateOneWithoutCompanyBelongInput
  email: String
  id: ID
  jobs: JobCreateManyWithoutJobsInput
  name: String!
  phoneNumber: String
  staffPrimary: StaffCreateOneWithoutStaffPrimaryInput!
  temporary: Boolean
}

input CustomerFilter {
  every: CustomerWhereInput
  none: CustomerWhereInput
  some: CustomerWhereInput
}

input CustomerOrderByInput {
  active: OrderByArg
  code: OrderByArg
  email: OrderByArg
  id: OrderByArg
  name: OrderByArg
  phoneNumber: OrderByArg
  temporary: OrderByArg
}

input CustomerScalarWhereInput {
  active: BooleanFilter
  addresses: AddressFilter
  AND: [CustomerScalarWhereInput!]
  code: StringFilter
  email: NullableStringFilter
  id: StringFilter
  jobs: JobFilter
  name: StringFilter
  NOT: [CustomerScalarWhereInput!]
  OR: [CustomerScalarWhereInput!]
  phoneNumber: NullableStringFilter
  temporary: BooleanFilter
}

input CustomerUpdateInput {
  active: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  code: String
  companyBelong: CompanyUpdateOneWithoutCustomersInput
  email: String
  id: ID
  jobs: JobUpdateManyWithoutCustomerInput
  name: String
  phoneNumber: String
  staffPrimary: StaffUpdateOneRequiredWithoutCustomerPrimariesInput
  staffSecondary: StaffUpdateOneWithoutCustomerSecondariesInput
  temporary: Boolean
}

input CustomerUpdateManyDataInput {
  active: Boolean
  code: String
  email: String
  id: ID
  name: String
  phoneNumber: String
  temporary: Boolean
}

input CustomerUpdateManyWithoutStaffPrimaryInput {
  connect: [CustomerWhereUniqueInput!]
  create: [CustomerCreateWithoutStaffPrimaryInput!]
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutStaffPrimaryInput!]
  updateMany: [CustomerUpdateManyWithWhereNestedInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutStaffPrimaryInput!]
}

input CustomerUpdateManyWithoutStaffSecondaryInput {
  connect: [CustomerWhereUniqueInput!]
  create: [CustomerCreateWithoutStaffSecondaryInput!]
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutStaffSecondaryInput!]
  updateMany: [CustomerUpdateManyWithWhereNestedInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutStaffSecondaryInput!]
}

input CustomerUpdateManyWithWhereNestedInput {
  data: CustomerUpdateManyDataInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateOneRequiredWithoutJobsInput {
  connect: CustomerWhereUniqueInput
  create: CustomerCreateWithoutJobsInput
  update: CustomerUpdateWithoutJobsDataInput
  upsert: CustomerUpsertWithoutJobsInput
}

input CustomerUpdateOneWithoutAddressesInput {
  connect: CustomerWhereUniqueInput
  create: CustomerCreateWithoutAddressesInput
  delete: Boolean
  disconnect: Boolean
  update: CustomerUpdateWithoutAddressesDataInput
  upsert: CustomerUpsertWithoutAddressesInput
}

input CustomerUpdateWithoutAddressesDataInput {
  active: Boolean
  code: String
  companyBelong: CompanyUpdateOneWithoutCustomersInput
  email: String
  id: ID
  jobs: JobUpdateManyWithoutCustomerInput
  name: String
  phoneNumber: String
  staffPrimary: StaffUpdateOneRequiredWithoutCustomerPrimariesInput
  staffSecondary: StaffUpdateOneWithoutCustomerSecondariesInput
  temporary: Boolean
}

input CustomerUpdateWithoutJobsDataInput {
  active: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  code: String
  companyBelong: CompanyUpdateOneWithoutCustomersInput
  email: String
  id: ID
  name: String
  phoneNumber: String
  staffPrimary: StaffUpdateOneRequiredWithoutCustomerPrimariesInput
  staffSecondary: StaffUpdateOneWithoutCustomerSecondariesInput
  temporary: Boolean
}

input CustomerUpdateWithoutStaffPrimaryDataInput {
  active: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  code: String
  companyBelong: CompanyUpdateOneWithoutCustomersInput
  email: String
  id: ID
  jobs: JobUpdateManyWithoutCustomerInput
  name: String
  phoneNumber: String
  staffSecondary: StaffUpdateOneWithoutCustomerSecondariesInput
  temporary: Boolean
}

input CustomerUpdateWithoutStaffSecondaryDataInput {
  active: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  code: String
  companyBelong: CompanyUpdateOneWithoutCustomersInput
  email: String
  id: ID
  jobs: JobUpdateManyWithoutCustomerInput
  name: String
  phoneNumber: String
  staffPrimary: StaffUpdateOneRequiredWithoutCustomerPrimariesInput
  temporary: Boolean
}

input CustomerUpdateWithWhereUniqueWithoutStaffPrimaryInput {
  data: CustomerUpdateWithoutStaffPrimaryDataInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithWhereUniqueWithoutStaffSecondaryInput {
  data: CustomerUpdateWithoutStaffSecondaryDataInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithoutAddressesInput {
  create: CustomerCreateWithoutAddressesInput!
  update: CustomerUpdateWithoutAddressesDataInput!
}

input CustomerUpsertWithoutJobsInput {
  create: CustomerCreateWithoutJobsInput!
  update: CustomerUpdateWithoutJobsDataInput!
}

input CustomerUpsertWithWhereUniqueWithoutStaffPrimaryInput {
  create: CustomerCreateWithoutStaffPrimaryInput!
  update: CustomerUpdateWithoutStaffPrimaryDataInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithWhereUniqueWithoutStaffSecondaryInput {
  create: CustomerCreateWithoutStaffSecondaryInput!
  update: CustomerUpdateWithoutStaffSecondaryDataInput!
  where: CustomerWhereUniqueInput!
}

input CustomerWhereInput {
  active: BooleanFilter
  addresses: AddressFilter
  AND: [CustomerWhereInput!]
  code: StringFilter
  companyBelong: CompanyWhereInput
  email: NullableStringFilter
  id: StringFilter
  jobs: JobFilter
  name: StringFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  phoneNumber: NullableStringFilter
  staffPrimary: StaffWhereInput
  staffSecondary: StaffWhereInput
  temporary: BooleanFilter
}

input CustomerWhereUniqueInput {
  code: String
  id: ID
  name: String
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Job {
  assignments(after: ID, before: ID, first: Int, last: Int, skip: Int): [Assignment!]!
  customer: Customer!
  dateIssued: DateTime!
  id: ID!
  needsFollowUp: Boolean!
}

input JobCreateInput {
  assignments: AssignmentCreateManyWithoutAssignmentsInput
  customer: CustomerCreateOneWithoutCustomerInput!
  dateIssued: DateTime
  id: ID
  needsFollowUp: Boolean
}

input JobCreateManyWithoutJobsInput {
  connect: [JobWhereUniqueInput!]
  create: [JobCreateWithoutCustomerInput!]
}

input JobCreateOneWithoutJobInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutAssignmentsInput
}

input JobCreateWithoutAssignmentsInput {
  customer: CustomerCreateOneWithoutCustomerInput!
  dateIssued: DateTime
  id: ID
  needsFollowUp: Boolean
}

input JobCreateWithoutCustomerInput {
  assignments: AssignmentCreateManyWithoutAssignmentsInput
  dateIssued: DateTime
  id: ID
  needsFollowUp: Boolean
}

input JobFilter {
  every: JobWhereInput
  none: JobWhereInput
  some: JobWhereInput
}

input JobOrderByInput {
  dateIssued: OrderByArg
  id: OrderByArg
  needsFollowUp: OrderByArg
}

input JobScalarWhereInput {
  AND: [JobScalarWhereInput!]
  assignments: AssignmentFilter
  dateIssued: DateTimeFilter
  id: StringFilter
  needsFollowUp: BooleanFilter
  NOT: [JobScalarWhereInput!]
  OR: [JobScalarWhereInput!]
}

input JobUpdateInput {
  assignments: AssignmentUpdateManyWithoutJobInput
  customer: CustomerUpdateOneRequiredWithoutJobsInput
  dateIssued: DateTime
  id: ID
  needsFollowUp: Boolean
}

input JobUpdateManyDataInput {
  dateIssued: DateTime
  id: ID
  needsFollowUp: Boolean
}

input JobUpdateManyWithoutCustomerInput {
  connect: [JobWhereUniqueInput!]
  create: [JobCreateWithoutCustomerInput!]
  delete: [JobWhereUniqueInput!]
  deleteMany: [JobScalarWhereInput!]
  disconnect: [JobWhereUniqueInput!]
  set: [JobWhereUniqueInput!]
  update: [JobUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [JobUpdateManyWithWhereNestedInput!]
  upsert: [JobUpsertWithWhereUniqueWithoutCustomerInput!]
}

input JobUpdateManyWithWhereNestedInput {
  data: JobUpdateManyDataInput!
  where: JobScalarWhereInput!
}

input JobUpdateOneWithoutAssignmentsInput {
  connect: JobWhereUniqueInput
  create: JobCreateWithoutAssignmentsInput
  delete: Boolean
  disconnect: Boolean
  update: JobUpdateWithoutAssignmentsDataInput
  upsert: JobUpsertWithoutAssignmentsInput
}

input JobUpdateWithoutAssignmentsDataInput {
  customer: CustomerUpdateOneRequiredWithoutJobsInput
  dateIssued: DateTime
  id: ID
  needsFollowUp: Boolean
}

input JobUpdateWithoutCustomerDataInput {
  assignments: AssignmentUpdateManyWithoutJobInput
  dateIssued: DateTime
  id: ID
  needsFollowUp: Boolean
}

input JobUpdateWithWhereUniqueWithoutCustomerInput {
  data: JobUpdateWithoutCustomerDataInput!
  where: JobWhereUniqueInput!
}

input JobUpsertWithoutAssignmentsInput {
  create: JobCreateWithoutAssignmentsInput!
  update: JobUpdateWithoutAssignmentsDataInput!
}

input JobUpsertWithWhereUniqueWithoutCustomerInput {
  create: JobCreateWithoutCustomerInput!
  update: JobUpdateWithoutCustomerDataInput!
  where: JobWhereUniqueInput!
}

input JobWhereInput {
  AND: [JobWhereInput!]
  assignments: AssignmentFilter
  customer: CustomerWhereInput
  dateIssued: DateTimeFilter
  id: StringFilter
  needsFollowUp: BooleanFilter
  NOT: [JobWhereInput!]
  OR: [JobWhereInput!]
}

input JobWhereUniqueInput {
  id: ID
}

type Mutation {
  createAdmin(data: AdminCreateInput!): Admin!
  createCompany(data: CompanyCreateInput!): Company!
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneJob(data: JobCreateInput!): Job!
  createStaff(data: StaffCreateInput!): Staff!
  deleteAdmin(where: AdminWhereUniqueInput!): Admin
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneJob(where: JobWhereUniqueInput!): Job
  deleteStaff(where: StaffWhereUniqueInput!): Staff
  forgotAdminPassword(username: String!): Boolean!
  forgotStaffPassword(where: StaffWhereUniqueInput!): Boolean!
  loginAdmin(password: String!, username: String!): AdminLoginResponse!
  loginStaff(password: String!, username: String!): StaffLoginResponse!
  resetAdminPassword(newPassword: String!, token: String!): Boolean!
  resetStaffPassword(newPassword: String!, where: StaffWhereUniqueInput!): Boolean!
  updateAdmin(data: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin
  updateAdminPassword(newPassword: String!, oldPassword: String!, where: AdminWhereUniqueInput!): Boolean!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneJob(data: JobUpdateInput!, where: JobWhereUniqueInput!): Job
  updateStaff(data: StaffUpdateInput!, where: StaffWhereUniqueInput!): Staff
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  admin(where: AdminWhereUniqueInput!): Admin
  admins(after: ID, before: ID, first: Int, last: Int, orderBy: AdminOrderByInput, skip: Int, where: AdminWhereInput): [Admin!]!
  companies(after: ID, before: ID, first: Int, last: Int, skip: Int): [Company!]!
  company(where: CompanyWhereUniqueInput!): Company
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(after: ID, before: ID, first: Int, last: Int, orderBy: CustomerOrderByInput, skip: Int, where: CustomerWhereInput): [Customer!]!
  job(where: JobWhereUniqueInput!): Job
  jobs(after: ID, before: ID, first: Int, last: Int, orderBy: JobOrderByInput, skip: Int, where: JobWhereInput): [Job!]!
  staff(where: StaffWhereUniqueInput!): Staff
  staffs(after: ID, before: ID, first: Int, last: Int, orderBy: StaffOrderByInput, skip: Int, where: StaffWhereInput): [Staff!]!
}

type Staff {
  fullName: String!
  id: ID!
  passwordForgotten: Boolean!
  username: String!
}

input StaffCreateInput {
  fullName: String!
  password: String!
  username: String!
}

input StaffCreateOneWithoutStaffPrimaryInput {
  connect: StaffWhereUniqueInput
  create: StaffCreateWithoutAssignmentPrimariesInput
}

input StaffCreateOneWithoutStaffSecondaryInput {
  connect: StaffWhereUniqueInput
  create: StaffCreateWithoutCustomerSecondariesInput
}

input StaffCreateWithoutAssignmentPrimariesInput {
  assignmentSecondaries: AssignmentCreateManyWithoutAssignmentSecondariesInput
  customerPrimaries: CustomerCreateManyWithoutCustomerPrimariesInput
  customerSecondaries: CustomerCreateManyWithoutCustomerSecondariesInput
  fullName: String!
  hash: String!
  id: ID
  passwordForgotten: Boolean
  username: String!
}

input StaffCreateWithoutAssignmentSecondariesInput {
  assignmentPrimaries: AssignmentCreateManyWithoutAssignmentPrimariesInput
  customerPrimaries: CustomerCreateManyWithoutCustomerPrimariesInput
  customerSecondaries: CustomerCreateManyWithoutCustomerSecondariesInput
  fullName: String!
  hash: String!
  id: ID
  passwordForgotten: Boolean
  username: String!
}

input StaffCreateWithoutCustomerPrimariesInput {
  assignmentPrimaries: AssignmentCreateManyWithoutAssignmentPrimariesInput
  assignmentSecondaries: AssignmentCreateManyWithoutAssignmentSecondariesInput
  customerSecondaries: CustomerCreateManyWithoutCustomerSecondariesInput
  fullName: String!
  hash: String!
  id: ID
  passwordForgotten: Boolean
  username: String!
}

input StaffCreateWithoutCustomerSecondariesInput {
  assignmentPrimaries: AssignmentCreateManyWithoutAssignmentPrimariesInput
  assignmentSecondaries: AssignmentCreateManyWithoutAssignmentSecondariesInput
  customerPrimaries: CustomerCreateManyWithoutCustomerPrimariesInput
  fullName: String!
  hash: String!
  id: ID
  passwordForgotten: Boolean
  username: String!
}

type StaffLoginResponse {
  staffId: String!
  token: String!
}

input StaffOrderByInput {
  fullName: OrderByArg
  hash: OrderByArg
  id: OrderByArg
  passwordForgotten: OrderByArg
  username: OrderByArg
}

input StaffUpdateInput {
  fullName: String
  username: String
}

input StaffUpdateOneRequiredWithoutAssignmentPrimariesInput {
  connect: StaffWhereUniqueInput
  create: StaffCreateWithoutAssignmentPrimariesInput
  update: StaffUpdateWithoutAssignmentPrimariesDataInput
  upsert: StaffUpsertWithoutAssignmentPrimariesInput
}

input StaffUpdateOneRequiredWithoutCustomerPrimariesInput {
  connect: StaffWhereUniqueInput
  create: StaffCreateWithoutCustomerPrimariesInput
  update: StaffUpdateWithoutCustomerPrimariesDataInput
  upsert: StaffUpsertWithoutCustomerPrimariesInput
}

input StaffUpdateOneWithoutAssignmentSecondariesInput {
  connect: StaffWhereUniqueInput
  create: StaffCreateWithoutAssignmentSecondariesInput
  delete: Boolean
  disconnect: Boolean
  update: StaffUpdateWithoutAssignmentSecondariesDataInput
  upsert: StaffUpsertWithoutAssignmentSecondariesInput
}

input StaffUpdateOneWithoutCustomerSecondariesInput {
  connect: StaffWhereUniqueInput
  create: StaffCreateWithoutCustomerSecondariesInput
  delete: Boolean
  disconnect: Boolean
  update: StaffUpdateWithoutCustomerSecondariesDataInput
  upsert: StaffUpsertWithoutCustomerSecondariesInput
}

input StaffUpdateWithoutAssignmentPrimariesDataInput {
  assignmentSecondaries: AssignmentUpdateManyWithoutStaffSecondaryInput
  customerPrimaries: CustomerUpdateManyWithoutStaffPrimaryInput
  customerSecondaries: CustomerUpdateManyWithoutStaffSecondaryInput
  fullName: String
  hash: String
  id: ID
  passwordForgotten: Boolean
  username: String
}

input StaffUpdateWithoutAssignmentSecondariesDataInput {
  assignmentPrimaries: AssignmentUpdateManyWithoutStaffPrimaryInput
  customerPrimaries: CustomerUpdateManyWithoutStaffPrimaryInput
  customerSecondaries: CustomerUpdateManyWithoutStaffSecondaryInput
  fullName: String
  hash: String
  id: ID
  passwordForgotten: Boolean
  username: String
}

input StaffUpdateWithoutCustomerPrimariesDataInput {
  assignmentPrimaries: AssignmentUpdateManyWithoutStaffPrimaryInput
  assignmentSecondaries: AssignmentUpdateManyWithoutStaffSecondaryInput
  customerSecondaries: CustomerUpdateManyWithoutStaffSecondaryInput
  fullName: String
  hash: String
  id: ID
  passwordForgotten: Boolean
  username: String
}

input StaffUpdateWithoutCustomerSecondariesDataInput {
  assignmentPrimaries: AssignmentUpdateManyWithoutStaffPrimaryInput
  assignmentSecondaries: AssignmentUpdateManyWithoutStaffSecondaryInput
  customerPrimaries: CustomerUpdateManyWithoutStaffPrimaryInput
  fullName: String
  hash: String
  id: ID
  passwordForgotten: Boolean
  username: String
}

input StaffUpsertWithoutAssignmentPrimariesInput {
  create: StaffCreateWithoutAssignmentPrimariesInput!
  update: StaffUpdateWithoutAssignmentPrimariesDataInput!
}

input StaffUpsertWithoutAssignmentSecondariesInput {
  create: StaffCreateWithoutAssignmentSecondariesInput!
  update: StaffUpdateWithoutAssignmentSecondariesDataInput!
}

input StaffUpsertWithoutCustomerPrimariesInput {
  create: StaffCreateWithoutCustomerPrimariesInput!
  update: StaffUpdateWithoutCustomerPrimariesDataInput!
}

input StaffUpsertWithoutCustomerSecondariesInput {
  create: StaffCreateWithoutCustomerSecondariesInput!
  update: StaffUpdateWithoutCustomerSecondariesDataInput!
}

input StaffWhereInput {
  AND: [StaffWhereInput!]
  assignmentPrimaries: AssignmentFilter
  assignmentSecondaries: AssignmentFilter
  customerPrimaries: CustomerFilter
  customerSecondaries: CustomerFilter
  fullName: StringFilter
  hash: StringFilter
  id: StringFilter
  NOT: [StaffWhereInput!]
  OR: [StaffWhereInput!]
  passwordForgotten: BooleanFilter
  username: StringFilter
}

input StaffWhereUniqueInput {
  id: ID
  username: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Task {
  id: ID!
  remarks: String!
  type: TaskType!
}

input TaskCreateManyWithoutTasksInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutAssignmentInput!]
}

input TaskCreateWithoutAssignmentInput {
  id: ID
  remarks: String!
  type: TaskType!
}

input TaskFilter {
  every: TaskWhereInput
  none: TaskWhereInput
  some: TaskWhereInput
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  id: StringFilter
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  remarks: StringFilter
  type: TaskType
}

enum TaskType {
  COMPLAINT
  DELIVERY
  OTHERS
  SERVICE
  TRANSPORT
}

input TaskUpdateManyDataInput {
  id: ID
  remarks: String
  type: TaskType
}

input TaskUpdateManyWithoutAssignmentInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutAssignmentInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutAssignmentInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutAssignmentInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateWithoutAssignmentDataInput {
  id: ID
  remarks: String
  type: TaskType
}

input TaskUpdateWithWhereUniqueWithoutAssignmentInput {
  data: TaskUpdateWithoutAssignmentDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithWhereUniqueWithoutAssignmentInput {
  create: TaskCreateWithoutAssignmentInput!
  update: TaskUpdateWithoutAssignmentDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  assignment: AssignmentWhereInput
  id: StringFilter
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  remarks: StringFilter
  type: TaskType
}

input TaskWhereUniqueInput {
  id: ID
}
