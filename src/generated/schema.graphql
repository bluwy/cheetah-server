### This file was generated by Nexus Schema
### Do not make changes to this file directly

type Action {
  createdAt: DateTime!
  id: ID!
  remarks: String!
  updatedAt: DateTime!
}

input ActionInput {
  id: ID
  remarks: String
}

type Admin {
  createdAt: DateTime!
  id: ID!
  privilege: AdminPrivilege!
  updatedAt: DateTime!
  username: String!
}

input AdminCreateInput {
  password: String!
  privilege: AdminPrivilege!
  username: String!
}

input AdminOrderByInput {
  createdAt: OrderByArg
  privilege: OrderByArg
  updatedAt: OrderByArg
  username: OrderByArg
}

enum AdminPrivilege {
  BASIC
  FULL
}

input AdminPrivilegeFilter {
  equals: AdminPrivilege
  in: [AdminPrivilege!]
  not: AdminPrivilege
  notIn: [AdminPrivilege!]
}

input AdminWhereInput {
  AND: [AdminWhereInput!]
  createdAt: DateTimeFilter
  NOT: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  privilege: AdminPrivilegeFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Company {
  alias: String!
  createdAt: DateTime!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

input CompanyCreateInput {
  alias: String!
  name: String!
}

input CompanyOrderByInput {
  alias: OrderByArg
  createdAt: OrderByArg
  name: OrderByArg
  updatedAt: OrderByArg
}

input CompanyWhereInput {
  alias: StringFilter
  AND: [CompanyWhereInput!]
  createdAt: DateTimeFilter
  name: StringFilter
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  updatedAt: DateTimeFilter
}

type Customer {
  active: Boolean!
  addresses: [String!]!
  code: String!
  companyBelong: Company!
  createdAt: DateTime!
  email: String
  id: ID!
  name: String!
  phoneNumber: String
  staffPrimary: Staff!
  staffSecondary: Staff
  updatedAt: DateTime!
}

input CustomerCreateInput {
  addresses: [String!]!
  code: String!
  companyBelongId: ID!
  email: String
  name: String!
  phoneNumber: String
  staffPrimaryId: ID!
  staffSecondaryId: ID
}

input CustomerOrderByInput {
  active: OrderByArg
  code: OrderByArg
  companyBelong: CompanyOrderByInput
  createdAt: OrderByArg
  email: OrderByArg
  name: OrderByArg
  phoneNumber: OrderByArg
  staffPrimary: StaffOrderByInput
  staffSecondary: StaffOrderByInput
  updatedAt: OrderByArg
}

input CustomerUpdateInput {
  active: Boolean
  addresses: [String!]
  code: String
  companyBelongId: ID
  email: String
  name: String
  phoneNumber: String
  staffPrimaryId: ID
  staffSecondaryId: ID
}

input CustomerWhereInput {
  active: BooleanFilter
  AND: [CustomerWhereInput!]
  code: StringFilter
  companyBelong: CompanyWhereInput
  createdAt: DateTimeFilter
  email: StringFilter
  name: StringFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  phoneNumber: StringFilter
  staffPrimary: StaffWhereInput
  staffSecondary: StaffWhereInput
  updatedAt: DateTimeFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Job {
  actions: [Action!]!
  address: String!
  checkIn: DateTime
  checkOut: DateTime
  code: String!
  createdAt: DateTime!
  customer: Customer!
  id: ID!
  staffPrimary: Staff!
  staffSecondary: Staff
  startDate: DateTime!
  state: JobState!
  tasks: [Task!]!
  updatedAt: DateTime!
}

input JobCreateInput {
  address: String!
  customerId: ID!
  staffPrimaryId: ID!
  staffSecondaryId: ID
  startDate: DateTime!
  tasks: [TaskCreateInput!]!
}

input JobOrderByInput {
  address: OrderByArg
  checkIn: OrderByArg
  checkOut: OrderByArg
  code: OrderByArg
  createdAt: OrderByArg
  customer: CustomerOrderByInput
  staffPrimary: StaffOrderByInput
  staffSecondary: StaffOrderByInput
  startDate: OrderByArg
  state: OrderByArg
  updatedAt: OrderByArg
}

input JobReassignInput {
  address: String!
  staffPrimaryId: ID!
  staffSecondaryId: ID
  startDate: DateTime!
  tasks: [TaskCreateInput!]!
}

type JobReassignResponse {
  newJob: Job!
  oriJob: Job!
}

enum JobState {
  DONE
  EXPIRED
  FOLLOW_UP
  REVIEWED
  TODO
}

input JobStateFilter {
  equals: JobState
  in: [JobState!]
  not: JobState
  notIn: [JobState!]
}

input JobUpdateByAdminInput {
  address: String
  checkIn: DateTime
  checkOut: DateTime
  customerId: ID
  staffPrimaryId: ID
  staffSecondaryId: ID
  startDate: DateTime
  state: JobState
}

input JobUpdateByStaffInput {
  checkIn: DateTime
  checkOut: DateTime
  state: JobState
}

input JobWhereInput {
  address: StringFilter
  AND: [JobWhereInput!]
  checkIn: DateTimeFilter
  checkOut: DateTimeFilter
  code: StringFilter
  createdAt: DateTimeFilter
  customer: CustomerWhereInput
  NOT: [JobWhereInput!]
  OR: [JobWhereInput!]
  staffPrimary: StaffWhereInput
  staffSecondary: StaffWhereInput
  startDate: DateTimeFilter
  state: JobStateFilter
  updatedAt: DateTimeFilter
}

type Mutation {
  adminCreate(data: AdminCreateInput!, sudoPassword: String): Admin!
  adminDelete(id: ID): Boolean!
  adminGetResetPasswordToken(sudoPassword: String!, username: String!): String!
  adminLogin(password: String!, username: String!): Boolean!
  adminLogout: Boolean!
  adminResetPassword(newPassword: String!, resetToken: String!): Boolean!
  adminUpdatePassword(
    id: ID
    newPassword: String!
    oldPassword: String!
  ): Boolean!
  companyCreate(data: CompanyCreateInput!): Company!
  companyDelete(id: ID!): Boolean!
  customerCreate(data: CustomerCreateInput!): Customer!
  customerDelete(id: ID!): Boolean!
  customerUpdate(data: CustomerUpdateInput!, id: ID!): Customer!
  jobCreate(data: JobCreateInput!): Job!
  jobDelete(id: ID!): Boolean!
  jobFinish(id: ID!): Job!
  jobReassign(data: JobReassignInput!, id: ID!): JobReassignResponse!
  jobSetActions(data: [ActionInput!]!, jobId: ID!): Boolean!
  jobSetTasks(data: [TaskInput!]!, jobId: ID!): Boolean!
  jobSetTasksDone(ids: [ID!]!): Boolean!
  jobUpdateByAdmin(data: JobUpdateByAdminInput!, id: ID!): Job!
  jobUpdateByStaff(data: JobUpdateByStaffInput!, id: ID!): Job!
  staffCreate(data: StaffCreateInput!): Staff!
  staffDelete(id: ID): Boolean!
  staffLogin(deviceId: String!, username: String!): Boolean!
  staffLogout: Boolean!
  staffPairDevice(deviceId: String!, username: String!): Boolean!
  staffResetPairing(id: ID!): Boolean!
  staffUpdate(data: StaffUpdateInput!, id: ID): Staff!
}

enum OrderByArg {
  ASC
  DESC
}

type Query {
  admin(id: ID): Admin!
  adminCount(query: String, where: AdminWhereInput): Int!
  adminIsInSession: Boolean!
  admins(
    orderBy: AdminOrderByInput
    query: String
    where: AdminWhereInput
  ): [Admin!]!
  companies(
    orderBy: CompanyOrderByInput
    query: String
    where: CompanyWhereInput
  ): [Company!]!
  company(id: ID!): Company!
  companyCount(query: String, where: CompanyWhereInput): Int!
  customer(id: ID!): Customer!
  customerCount(query: String, where: CustomerWhereInput): Int!
  customers(
    first: Int = 10
    orderBy: CustomerOrderByInput
    query: String
    skip: Int = 0
    where: CustomerWhereInput
  ): [Customer!]!
  job(id: ID!): Job!
  jobCount(query: String, where: JobWhereInput): Int!
  jobs(
    first: Int = 10
    orderBy: JobOrderByInput
    query: String
    skip: Int = 0
    where: JobWhereInput
  ): [Job!]!
  staff(id: ID): Staff!
  staffCount(query: String, where: StaffWhereInput): Int!
  staffIsInSession: Boolean!
  staffs(
    orderBy: StaffOrderByInput
    query: String
    where: StaffWhereInput
  ): [Staff!]!
}

type Staff {
  active: Boolean!
  createdAt: DateTime!
  fullName: String!
  id: ID!
  paired: Boolean!
  updatedAt: DateTime!
  username: String!
}

input StaffCreateInput {
  fullName: String!
  username: String!
}

input StaffOrderByInput {
  active: OrderByArg
  createdAt: OrderByArg
  fullName: OrderByArg
  updatedAt: OrderByArg
  username: OrderByArg
}

input StaffUpdateInput {
  active: Boolean
  fullName: String
}

input StaffWhereInput {
  active: BooleanFilter
  AND: [StaffWhereInput!]
  createdAt: DateTimeFilter
  fullName: StringFilter
  NOT: [StaffWhereInput!]
  OR: [StaffWhereInput!]
  updatedAt: DateTimeFilter
  username: StringFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Task {
  createdAt: DateTime!
  done: Boolean!
  id: ID!
  remarks: String!
  type: TaskType!
  updatedAt: DateTime!
}

input TaskCreateInput {
  remarks: String!
  type: TaskType!
}

input TaskInput {
  done: Boolean
  id: ID
  remarks: String
  type: TaskType
}

enum TaskType {
  COMPLAINT
  DELIVERY
  OTHERS
  SERVICE
  TRANSPORT
}

input TaskTypeFilter {
  equals: TaskType
  in: [TaskType!]
  not: TaskType
  notIn: [TaskType!]
}
